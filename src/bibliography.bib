@incollection{Jan+10,
  title         = {On testing answer-set programs},
  author        = {Janhunen, Tomi and Niemelä, Ilkka and Oetsch, Johannes and Pührer, Jörg and Tompits, Hans},
  booktitle     = {ECAI 2010},
  pages         = {951--956},
  year          = {2010},
  publisher     = {IOS Press}
}

@InProceedings{Jan+11,
  author        = {Janhunen, Tomi and Niemelä, Ilkka and Oetsch, Johannes and Pührer, Jörg and Tompits, Hans},
  editor        = {Delgrande, James P. and Faber, Wolfgang},
  title         = {Random vs. Structure-Based Testing of Answer-Set Programs: An Experimental Comparison},
  booktitle     = {Logic Programming and Nonmonotonic Reasoning},
  year          = {2011},
  publisher     = {Springer Berlin Heidelberg},
  address       = {Berlin, Heidelberg},
  pages         = {242--247},
  abstract      = {Answer-set programming (ASP) is an established paradigm for declarative problem solving, yet comparably little work on testing of answer-set programs has been done so far. In a recent paper, foundations for structure-based testing of answer-set programs building on a number of coverage notions have been proposed. In this paper, we develop a framework for testing answer-set programs based on this work and study how good the structure-based approach to test input generation is compared to random test input generation. The results indicate that random testing is quite ineffective for some benchmarks, while structure-based techniques catch faults with a high rate more consistently also in these cases.},
  isbn          = {978-3-642-20895-9}
}

@INPROCEEDINGS{Hem15,
  author        = {Hemmati, Hadi},
  booktitle     = {2015 IEEE International Conference on Software Quality, Reliability and Security}, 
  title         = {How Effective Are Code Coverage Criteria?}, 
  year          = {2015},
  volume        = {},
  number        = {},
  pages         = {151-156},
  doi           = {10.1109/QRS.2015.30}
}

@article{TH02,
  author        = {Tikir, Mustafa M. and Hollingsworth, Jeffrey K.},
  title         = {Efficient Instrumentation for Code Coverage Testing},
  year          = {2002},
  issue_date    = {July 2002},
  publisher     = {Association for Computing Machinery},
  address       = {New York, NY, USA},
  volume        = {27},
  number        = {4},
  issn          = {0163-5948},
  url           = {https://doi.org/10.1145/566171.566186},
  doi           = {10.1145/566171.566186},
  abstract      = {Evaluation of Code Coverage is the problem of identifying the parts of a program that did not execute in one or more runs of a program. The traditional approach for code coverage tools is to use static code instrumentation. In this paper we present a new approach to dynamically insert and remove instrumentation code to reduce the runtime overhead of code coverage. We also explore the use of dominator tree information to reduce the number of instrumentation points needed. Our experiments show that our approach reduces runtime overhead by 38-90% compared with purecov, a commercial code coverage tool. Our tool is fully automated and available for download from the Internet.},
  journal       = {SIGSOFT Softw. Eng. Notes},
  month         = {jul},
  pages         = {86–96},
  numpages      = {11},
  keywords      = {dynamic code patching, testing, code coverage, on-demand instrumentation, dominator tree, dynamic code deletion}
  }
  

@article{WDC10,
  title         = {A family of code coverage-based heuristics for effective fault localization},
  journal       = {Journal of Systems and Software},
  volume        = {83},
  number        = {2},
  pages         = {188-208},
  year          = {2010},
  note          = {Computer Software and Applications},
  issn          = {0164-1212},
  doi           = {https://doi.org/10.1016/j.jss.2009.09.037},
  url           = {https://www.sciencedirect.com/science/article/pii/S0164121209002465},
  author        = {W. {Eric Wong} and Vidroha Debroy and Byoungju Choi},
  keywords      = {Fault localization, Program debugging, Code coverage, Heuristics, Suspiciousness of code, Successful tests, Failed tests},
  abstract      = {Locating faults in a program can be very time-consuming and arduous, and therefore, there is an increased demand for automated techniques that can assist in the fault localization process. In this paper a code coverage-based method with a family of heuristics is proposed in order to prioritize suspicious code according to its likelihood of containing program bugs. Highly suspicious code (i.e., code that is more likely to contain a bug) should be examined before code that is relatively less suspicious; and in this manner programmers can identify and repair faulty code more efficiently and effectively. We also address two important issues: first, how can each additional failed test case aid in locating program faults; and second, how can each additional successful test case help in locating program faults. We propose that with respect to a piece of code, the contribution of the first failed test case that executes it in computing its likelihood of containing a bug is larger than or equal to that of the second failed test case that executes it, which in turn is larger than or equal to that of the third failed test case that executes it, and so on. This principle is also applied to the contribution provided by successful test cases that execute the piece of code. A tool, χDebug, was implemented to automate the computation of the suspiciousness of the code and the subsequent prioritization of suspicious code for locating program faults. To validate our method case studies were performed on six sets of programs: Siemens suite, Unix suite, space, grep, gzip, and make. Data collected from the studies are supportive of the above claim and also suggest Heuristics III(a), (b) and (c) of our method can effectively reduce the effort spent on fault localization.}
}


